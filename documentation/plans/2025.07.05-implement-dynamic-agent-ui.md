# Plan: Implement Dynamic, Schema-Driven UI for Agent Settings

**Date:** 2025-07-05
**Status:** Proposed

## 1. Objective

To implement a flexible UI system for agent settings where the UI elements (text inputs, checkboxes, lists of fields, etc.) are dynamically rendered based on a JSON schema defined within each agent's configuration. This will allow for creating diverse and powerful agents without requiring frontend code changes for each new type of setting.

## 2. Background

Currently, the agent settings page has a fixed set of fields. As we create more specialized agents, we need the ability to add custom configuration fields on a per-agent basis. For example, a "GitHub Labeler" agent might need a field for the repository name, while an "Email Summarizer" might need a field for summary length. A hardcoded approach is not scalable.

The chosen solution is a schema-driven UI, where the backend provides a declarative JSON object that the frontend uses to build the form.

## 3. High-Level Plan

The implementation will be broken down into five main stages:
1.  **Update Data Models**: Extend the `Agent` model on both the backend and frontend to include fields for `param_schema` and `param_values`.
2.  **Create a Renderer Component**: Build a new, reusable React component (`DynamicFieldRenderer`) that can parse the `param_schema` and render the appropriate form controls.
3.  **Create Custom Parameters UI**: Build a new, self-contained `CustomParameters.tsx` component to render the dynamic UI as a separate section.
4.  **Update Backend**: Ensure the API endpoint for updating agents correctly handles and persists the new fields.
5.  **Implement Prompt Injection**: Modify the agent runner to perform the placeholder replacements before executing an agent.

## 3.5. Prompt Injection Strategy

To make the custom settings useful to the agent, their values will be injected into the agent's prompts (`system_prompt` and `user_instructions`) before execution. This will be handled by the `agent/internals/runner.py`.

Two methods of injection will be supported:

1.  **Bulk Injection**: The placeholder `<<PARAM_VALUES>>` will be replaced with a JSON string representation of the entire `param_values` object. This gives the LLM full context of all custom parameters.

2.  **Individual Injection**: For more direct access, each field in the `param_schema` can define an `injection_key`. The runner will then replace `<<INJECTION_KEY>>` with the corresponding value. This is useful for simple, direct substitutions.
    - If the value is a **simple type** (string, number, boolean), it will be converted to a string for replacement.
    - If the value is a **complex type** (e.g., a list of objects), it will be **JSON-serialized** before injection, ensuring the agent receives a structured, machine-readable format.

### Example `param_schema` with Injection Keys

```json
[
  {
    "parameter_key": "reply_language",
    "display_text": "Language for Replies",
    "type": "text",
    "injection_key": "REPLY_LANGUAGE"
  },
  {
    "parameter_key": "use_bullet_points",
    "display_text": "Use Bullet Points in Summary",
    "type": "checkbox",
    "injection_key": "USE_BULLETS"
  },
  {
    "parameter_key": "labeling_rules",
    "display_text": "Content-Based Labeling Rules",
    "type": "list",
    "injection_key": "LABELING_RULES",
    "item_schema": [
      { "parameter_key": "keyword", "display_text": "If content contains...", "type": "text" },
      { "parameter_key": "label_to_apply", "display_text": "Apply this label", "type": "text" }
    ]
  }
]
```

### Example `param_values` Data

```json
{
  "reply_language": "German",
  "use_bullet_points": true,
  "labeling_rules": [
    {
      "keyword": "invoice",
      "label_to_apply": "Finance"
    },
    {
      "keyword": "bug report",
      "label_to_apply": "Tech"
    },
    {
      "keyword": "feedback",
      "label_to_apply": "Product"
    }
  ]
}
```

### Example `user_instructions` Template

```
Please summarize the email. Your reply must be in <<REPLY_LANGUAGE>>.
Decide if you should use bullet points: <<USE_BULLETS>>.
Use the following rules for labeling: <<LABELING_RULES>>
```

### Resulting `user_instructions` after injection

```
Please summarize the email. Your reply must be in German.
Decide if you should use bullet points: true.
Use the following rules for labeling: [{"keyword": "invoice", "label_to_apply": "Finance"}]
```

## 3.6 Data Flow for `param_schema`

To clarify how the frontend receives the schema, the following data flow will be implemented:

1.  **Origin in Templates**: The `param_schema` for a type of agent is defined by the developer directly within agent template files (e.g., `api/agent_templates/github_labeler.json`). These templates will include both the `param_schema` (the UI blueprint) and default `param_values`.

2.  **Storage in Database**: When a user creates a new agent from a template, the backend copies the `param_schema` and `param_values` from the template file into the new agent's record in the database. These become properties of the specific agent instance.

3.  **Transmission to Frontend**: When a user selects an agent in the UI, the frontend makes an API call to fetch the agent's data. The backend responds with the full `Agent` object, which now includes the `param_schema` and `param_values` fields. The frontend then uses this schema to dynamically render the `CustomParameters` component.

## 4. Detailed Implementation Steps

### Step 1: Update Data Models (Backend & Frontend)

-   **Backend (`api/types/api_models/agent.py`):**
    -   Modify the `Agent` Pydantic model.
    -   Add `param_values: Optional[Dict[str, Any]] = Field(default_factory=dict)`. This will store the key-value data from the dynamic form.
    -   Add `param_schema: Optional[List[Dict[str, Any]]] = Field(default_factory=list)`. This will hold the JSON schema defining the UI.

-   **Frontend (`frontend/services/api.ts`):**
    -   Update the `Agent` TypeScript interface to match the backend.
    -   Add `param_values?: { [key: string]: any };`
    -   Add `param_schema?: ParamSchemaField[];`
    -   Define a new `ParamSchemaField` interface to provide type safety for the schema objects. It will include properties like `parameter_key`, `display_text`, `type` (`text`, `checkbox`, `list`), an optional `injection_key: string`, and optionally `item_schema` for lists of complex objects.

### Step 2: Create the `DynamicFieldRenderer` Component

-   **Create New File:** `frontend/components/DynamicFieldRenderer.tsx`.
-   **Props:** The component will accept `field: ParamSchemaField`, `value: any`, and `onChange: (parameterKey, value) => void`.
-   **Logic:**
    -   Use a `switch` statement based on `field.type` to render the correct HTML input.
    -   For `type: 'list'`, it will manage the state of an array. It will render a list of inputs, each with a "Remove" button, and an "Add" button to append a new item to the list.
    -   It will be designed to handle recursion for nested schemas (e.g., a list of objects, where each object has its own set of fields).
    -   **It should implement TypeScript's exhaustiveness check** on the `switch` statement to ensure all field types are handled, preventing future bugs.

### Step 3: Create the Custom Parameters UI Component

To add the dynamic UI without altering the existing, stable `AgentSettings.tsx` component, we will create a new, self-contained component for the custom parameters.

-   **Create New File:** `frontend/components/CustomParameters.tsx`.
-   **Responsibilities:**
    -   This component will be a self-contained card with its own title (e.g., "Custom Parameters") and a `SaveButton`.
    -   It will receive the `param_schema`, `param_values`, a change handler (`onParamValuesChange`), and the save handler (`onSave`) as props.
    -   It will map over the `param_schema` array and render the `<DynamicFieldRenderer />` for each parameter.
    -   This component will have **no knowledge** of other agent settings like tools or user instructions.
-   **Integration into `AgentSettings.tsx`:**
    -   The `AgentSettings.tsx` component will remain structurally unchanged. Its existing logic for general, trigger, and agent settings will **not be moved or refactored**.
    -   The state for `param_values` and the handler `handleParamValuesChange` will be managed within `AgentSettings.tsx`.
    -   `AgentSettings.tsx` will render the new `<CustomParameters />` component as a new, distinct card within its main layout, passing the required data and handlers as props.

### Step 4: Update Backend API and Database

-   **API Endpoint (`api/endpoints/agent.py`):**